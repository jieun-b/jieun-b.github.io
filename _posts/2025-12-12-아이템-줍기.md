---
title: "[프로그래머스] 코딩테스트 고득점 Kit – 아이템 줍기"
date: 2025-12-12 00:00:00 +0900
layout: post
categories: [공부, Algorithm]
tags: [BFS]
---
## 문제

[Level3: 아이템 줍기](https://school.programmers.co.kr/learn/courses/30/lessons/87694#)

### 문제 요약

- 캐릭터의 시작점에서 아이템 위치까지 **최단 거리**를 구하는 문제
- 여러 직사각형이 겹쳐 있는 지형에서 **가장 바깥 테두리만 이동 가능**
- 직사각형끼리 **겹치거나 변이 완전히 일치하는 일은 없으며 닿아 있는** 것은 가능
- 직사각형 내부나 두 테두리 사이 공간으로는 이동할 수 없음

## 풀이 아이디어

- 좌표 1칸 단위로 BFS 탐색을 수행
- 모든 이동 후보 `(x → nx)`에 대해 **테두리를 따라 이동하는 올바른 간선인지** 판별 → `is_valid()`
- 유효한 이동 조건:
    1. 다음 위치 `(nx, ny)`가 사각형 내부에 있지 않음
    2. 선분 `cur → next`가 사각형을 가로지르지 않음 (폭이 1이거나 높이 1인 직사각형일 때 생기는 문제 방지)
    3. 현재 위치와 다음 위치가 같은 사각형의 테두리에 위치해야 하며, 단 하나의 사각형에서만 같이 존재해야 함
- 조건을 모두 통과하면 큐에 추가하고, `(itemX, itemY)`에 도달 시 누적 거리 반환

## 코드

```python
from collections import deque

def solution(rectangle, characterX, characterY, itemX, itemY):
    answer = 0
    
    d = [(0,1), (0,-1), (-1,0), (1,0)]
    queue = deque([(characterX, characterY, 0)])
    visited = set([(characterX, characterY)])

    def is_edge(x, y, lx, ly, rx, ry):
        if (x == lx or x == rx) and ly <= y <= ry:
            return True
        if (y == ly or y == ry) and lx <= x <= rx:
            return True
        return False
    
    def is_valid(x, y, nx, ny):
        # 조건 1
        for lx, ly, rx, ry in rectangle:
            if lx < nx < rx and ly < ny < ry:
                return False
        # 조건 2 
        for lx, ly, rx, ry in rectangle:
            if rx - lx == 1:
                if y == ny and ly < ny < ry:
                    if((lx == x and rx == nx) or (lx == nx and rx == x)):
                        return False
            elif ry - ly == 1:
                if x == nx and lx < nx < rx:
                    if((ly == y and ry == ny) or (ly == ny and ry == y)):
                        return False
        # 조건 3
        cnt = 0
        for lx, ly, rx, ry in rectangle:
            if is_edge(x, y, lx, ly, rx, ry) and is_edge(nx, ny, lx, ly, rx, ry):
                cnt += 1
            
        if cnt != 1:
            return False
        return True
        
    while queue:
        x, y, dis = queue.popleft()
        if (x, y) == (itemX, itemY):
            return dis 
        for k in range(4):
            nx, ny = x+d[k][0], y+d[k][1]
            if 0<nx<=50 and 0<ny<=50 and (nx, ny) not in visited:
                if is_valid(x, y, nx, ny):
                    queue.append((nx, ny, dis+1))
                    visited.add((nx, ny))
        
    return answer
```