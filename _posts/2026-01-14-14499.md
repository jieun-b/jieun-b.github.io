---
title: "[백준] 14499번: 주사위 굴리기"
date: 2026-01-14 20:00:00 +0900
layout: post
categories: [공부, Algorithm]
tags: [구현, 시뮬레이션]
---
## 문제

[14499**번: 주사위 굴리기**](https://www.acmicpc.net/problem/14499)

### 문제 요약

- `N x M` 크기의 지도에서 주사위를 굴림
- 주사위 시작 위치 `(x, y)`와 이동 명령 `K`개가 주어짐
- 명령은 `1(동)`, `2(서)`, `3(북)`, `4(남)`
- 주사위가 지도를 벗어나게 되는 명령은 **무시** (이동/출력 없음)
- 이동이 가능한 경우, 주사위를 굴린 다음 현재 칸과 주사위 **바닥면**을 다음 규칙으로 갱신
    - 칸의 값이 `0`이면: `칸 ← 바닥면`
    - 칸의 값이 `0`이 아니면: `바닥면 ← 칸`, 그리고 `칸 ← 0`
- 이동이 성공할 때마다 주사위 **윗면** 값을 출력


## 풀이 아이디어

### 1. 주사위 표현

- 주사위 6면을 리스트로 저장
- 인덱스 의미(코드 기준):
    - `dice[0]` : 위
    - `dice[1]` : 아래
    - `dice[2]` : 북
    - `dice[3]` : 남
    - `dice[4]` : 동
    - `dice[5]` : 서

### 2. 이동 처리

- 방향별 이동은 `dx, dy`로 처리
- 다음 좌표 `(nx, ny)`가 범위 안이면 이동하고, 범위를 벗어나면 해당 명령은 건너뜀

### 3. 주사위 굴리기

- 주사위를 직접 회전시키는 대신, 방향별로 **인덱스 재배치**를 정의해 한 번에 갱신
- 예를 들어 동쪽(`1`)으로 굴리면 다음 관계가 생김
    - `위 ← 서`, `아래 ← 동`, `동 ← 위`, `서 ← 아래` (북/남은 그대로)
- 이를 `rot[dir]`로 준비해두고, `dice = [dice[idx] for idx in rot[dir]]`로 갱신

### 4. 칸 값 처리

- 주사위를 굴린 뒤, 현재 칸 `graph[x][y]`와 `dice[1]`(바닥면)을 규칙대로 갱신
- 이후 `dice[0]`(윗면)을 출력

### 5. 복잡도

- 각 명령을 O(1)로 처리하므로 전체 시간 복잡도는 `O(K)`


## 코드

```python
import sys
input = sys.stdin.readline

n, m, x, y, k = map(int, input().split())
graph = [list(map(int, input().split())) for _ in range(n)]
order = list(map(int, input().split()))

dice = [0, 0, 0, 0, 0, 0] # 위 아래 북 남 동 서
rot = {
    1: [5, 4, 2, 3, 0, 1], # 동
    2: [4, 5, 2, 3, 1, 0], # 서
    3: [3, 2, 0, 1, 4, 5], # 북
    4: [2, 3, 1, 0, 4, 5], # 남
}

dx = [0, 0, -1, 1] # 동 서 북 남
dy = [1, -1, 0, 0]

for dir in order:
    nx, ny = x+dx[dir-1], y+dy[dir-1]
    if 0<=nx<n and 0<=ny<m:
        x, y = nx, ny
        dice = [dice[idx] for idx in rot[dir]]
        if graph[x][y] == 0:
            graph[x][y] = dice[1]
        else:
            dice[1] = graph[x][y]
            graph[x][y] = 0
        print(dice[0])
```