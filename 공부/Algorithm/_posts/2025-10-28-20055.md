---
title: "백준 20055번: 컨베이어 벨트 위의 로봇"
date: 2025-10-28 00:00:00 +0900
layout: post
tags: [구현, 시뮬레이션]
---
## 문제

[20055**번: 컨베이어 벨트 위의 로봇**](https://www.acmicpc.net/problem/20055)

### 문제 요약

길이가 `2N`인 벨트가 있고 로봇을 `1~N`의 위치에만 올릴 수 있을 때, 컨베이어 벨트를 이용해 로봇을 옮기는 과정:

1. 벨트가 한 칸 회전
2. 로봇은 먼저 올라간 순서대로 한 칸 이동
    - 이동하려는 칸에 다른 로봇이 없고
    - 내구도가 1 이상이면 이동 후 내구도 1 감소
3. 올리는 위치에 로봇을 새로 올림 → 내구도 1 감소
4. 내구도가 0인 칸의 개수가 K개 이상이면 종료
    - 종료되기 전까지 수행한 단계 수를 출력

## 풀이 아이디어

### 1. 자료 구조

- `belt`: 내구도 저장용 `deque` → `rotate(1)`로 회전
- `robot`: 로봇 위치 상태(`list`)

### 2. 시뮬레이션 과정

- 벨트와 로봇을 함께 한 칸 회전 (`rotate`, `pop`, `insert`)
- **뒤에서 앞으로** 로봇 이동
    - 앞칸 비어 있고 내구도 > 0이면 이동 + 내구도 1 감소
- 올리는 위치(`0`) 내구도 > 0이면 로봇 올림
- 내구도 0의 개수가 K 이상이면 종료

## 코드

```python
import sys
from collections import deque
input = sys.stdin.readline

# 벨트 회전은 push/pop으로 실행
# 벨트가 회전할 때 리스트도 자르고 추가하기

# 벨트 위의 상태는 리스트로 저장
# 로봇 이동
# 내구도가 0인 칸의 정보는 계속 기록

n, k = map(int, input().split())
belt = deque(map(int, input().split()))
robot = [False]*n

zero = 0
step = 0
while(True):
    step += 1
    # 벨트, 로봇 회전
    belt.rotate(1)
    robot.pop()
    robot.insert(0, False)
    robot[-1] = False
    # 로봇 이동, 이동하는 경우 내구도 감소
    for i in range(n-2, -1, -1):
        if robot[i] and not robot[i+1] and belt[i+1] > 0:
            robot[i], robot[i+1] = False, True
            belt[i+1] -= 1
            if belt[i+1] == 0:
                zero += 1
    robot[-1] = False
    # 로봇 올리기 
    if belt[0] > 0:
        robot[0] = True
        belt[0] -= 1
        if belt[0] == 0:
            zero += 1
    if zero >= k:
        break

print(step)
```