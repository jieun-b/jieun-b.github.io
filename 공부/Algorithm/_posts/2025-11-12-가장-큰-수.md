---
title: "[프로그래머스] 코딩테스트 고득점 Kit – 가장 큰 수"
date: 2025-11-12 00:00:00 +0900
layout: post
tags: [정렬]
---
## 문제

[Level 2: 가장 큰 수](https://school.programmers.co.kr/learn/courses/30/lessons/42746)

### 문제 요약

- 0 또는 양의 정수로 이루어진 배열이 주어짐
- 각 정수를 **이어 붙여 만들 수 있는 수 중 가장 큰 수**를 찾아야 함
- 배열의 순서를 재배치하여 만들 수 있음
- 결과는 **가장 큰 수를 문자열 형태로 반환**

## 풀이 아이디어

- 두 수 `a`, `b`를 문자열로 변환해 `a+b`와 `b+a`를 비교
- 더 큰 조합이 앞에 오도록 정렬하면 가장 큰 수를 만들 수 있음

## 코드

### 방법 1. 퀵소트 정렬

- 정렬 기준을 직접 구현해 `pivot`을 기준으로 **좌/우 배열 분리**
- 문자열 결합 비교(`a+b`, `b+a`)를 통해 정렬 순서를 결정
- 재귀적으로 정렬을 수행하여 결과 생성

```python
def solution(numbers):
    
    def quick_sort(arr):
        if len(arr) <= 1:
            return arr
        pivot = arr[0]
        left, right = [], []
        for i in range(1, len(arr)):
            if int(pivot+arr[i]) < int(arr[i]+pivot):
                left.append(arr[i])
            else:
                right.append(arr[i])
        return quick_sort(left) + [pivot] + quick_sort(right)
    
    numbers = list(map(str, numbers))
    arr = quick_sort(numbers)
    
    return str(int(''.join(arr)))
```

### 방법 2. `cmp_to_key` 를 활용한 정렬

- `functools.cmp_to_key`를 사용해 **비교 함수(`compare`)** 정의
- 두 문자열을 이어붙인 결과(`a+b`, `b+a`)를 비교해 순서 결정
- 내장 정렬(`sort`)을 사용하여 코드가 간결하고 효율적

```python
from functools import cmp_to_key

def solution(numbers):
    
    def compare(a, b):
        if a + b > b + a:
            return -1   
        else:
            return 1
    
    numbers = list(map(str, numbers))
    numbers.sort(key=cmp_to_key(compare))
    
    return str(int(''.join(numbers)))
```