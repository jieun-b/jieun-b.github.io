---
title: "[프로그래머스] 코딩테스트 고득점 Kit – 퍼즐 조각 채우기"
date: 2026-01-11 20:00:00 +0900
layout: post
categories: [공부, Algorithm]
tags: [BFS]
---
## 문제

[Level3: 퍼즐 조각 채우기](https://school.programmers.co.kr/learn/courses/30/lessons/84021)

### 문제 요약

- 게임 보드(`game_board`)에는 **빈 공간(0)** 과 **이미 채워진 칸(1)** 이 존재
- 테이블(`table`)에는 **퍼즐 조각(1)** 들이 흩어져 있음
- 퍼즐 조각과 빈 공간은 모두 **상·하·좌·우로 연결된 블록들의 집합**
- 퍼즐 조각을 빈 공간에 채울 때의 규칙:
    1. 퍼즐은 **한 번에 하나씩** 사용
    2. **회전은 가능**, **뒤집기는 불가능**
    3. 퍼즐을 놓은 후, **인접한 빈 칸이 남아 있으면 안 됨**
- 목표:
    - 퍼즐 조각을 적절히 배치하여 **채울 수 있는 칸의 최대 개수**를 구하기


## 풀이 아이디어

### 1. 연결된 블록 추출 (BFS)

- `find_blocks(board, flag)`
    - `flag = 0` → 게임 보드의 빈 공간
    - `flag = 1` → 테이블의 퍼즐 조각
- BFS를 이용해 **상·하·좌·우로 연결된 칸들을 하나의 블록**으로 묶음
- 결과:
    - `empty_blocks` : 게임 보드의 빈 공간 블록 리스트
    - `puzzle_blocks` : 테이블 위 퍼즐 블록 리스트

### 2. 블록 정규화 (normalize)

- 블록은 좌표 값이 서로 다르기 때문에 **형태 비교가 어려움**
- `normalize_block(block)`:
    - 블록의 최소 행/열을 기준으로 좌상단으로 이동
    - 2차원 배열(0/1) 형태로 변환
- 목적:
    - **위치와 무관하게 모양만 비교 가능하도록 변환**

### 3. 퍼즐 회전 후 매칭

- 각 빈 공간 블록에 대해:
    1. 같은 크기의 퍼즐 블록을 후보로 선택
    2. 퍼즐 블록을 **90°씩 최대 4번 회전**
    3. 회전 결과가 빈 공간과 **완전히 일치하면 사용**
- `rotate_block(block, empty_block)`:
    - `zip(*block[::-1])`을 이용해 시계 방향 회전
    - 4번 회전 중 하나라도 같으면 성공

### 4. 퍼즐 사용 처리

- 매칭에 성공한 퍼즐 조각은:
    - `puzzle_blocks`에서 제거 (중복 사용 방지)
    - 해당 블록의 칸 수를 `answer`에 누적

    
## 코드

```python
from collections import deque

dr = [1,0,-1,0]
dc = [0,1,0,-1]

def find_blocks(board, flag):
    blocks = []
    n = len(board)
    visited = [[False]*n for _ in range(n)]
    for i in range(n):
        for j in range(n):
            if not visited[i][j] and board[i][j] == flag:
                visited[i][j] = True
                queue = deque([(i,j)])
                block = [(i,j)]
                while queue:
                    r, c = queue.popleft()
                    for k in range(4):
                        nr, nc = r+dr[k], c+dc[k]
                        if 0<=nr<n and 0<=nc<n:
                            if not visited[nr][nc] and board[nr][nc] == flag:
                                block.append((nr,nc))
                                queue.append((nr,nc))
                                visited[nr][nc] = True
                blocks.append(block)
    return blocks

def normalize_block(block):
    r, c = zip(*block)
    h, w = max(r) - min(r) + 1, max(c) - min(c) + 1
    normalized_block = [[0]*w for _ in range(h)]
    for i, j in block:
        normalized_block[i-min(r)][j-min(c)] = 1
    return normalized_block

def rotate_block(block, empty_block):
    for k in range(4):
        block = list(map(list, zip(*block[::-1])))
        if block == empty_block:
            return True
    return False
    
def solution(game_board, table):
    answer = 0
    empty_blocks = find_blocks(game_board, 0)
    puzzle_blocks = find_blocks(table, 1)
    # 남은 공간 반복 확인
    for empty_block in empty_blocks:
        cnt = len(empty_block)
        empty_block = normalize_block(empty_block)
        # 퍼즐 확인
        for puzzle_block in puzzle_blocks:
            normalized_block = normalize_block(puzzle_block)
            # 퍼즐 회전
            if rotate_block(normalized_block, empty_block):
                puzzle_blocks.remove(puzzle_block)
                answer += cnt
                break
    return answer
```