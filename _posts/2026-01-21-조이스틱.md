---
title: "[프로그래머스] 코딩테스트 고득점 Kit – 조이스틱"
date: 2026-01-21 20:00:00 +0900
layout: post
categories: [공부, Algorithm]
tags: [Greedy]
---
## 문제

[Level2: 조이스틱](https://school.programmers.co.kr/learn/courses/30/lessons/42860)

### 문제 요약

- 시작 상태는 길이 `n`의 문자열 `"A" * n`이고, 커서는 첫 번째 칸(0번)에 위치
- `▲/▼` : 현재 칸의 알파벳을 다음/이전으로 변경 (`A`에서 `▼`하면 `Z`로 순환)
- `◀/▶` : 커서를 왼쪽/오른쪽으로 이동 (양 끝이 연결된 원형)
- 목표: 주어진 이름 `name`을 만들기 위한 조이스틱 조작 횟수의 최솟값을 반환


## 풀이 아이디어

### 1. 세로 이동(알파벳 변경) 비용

- 각 위치의 알파벳 변경은 서로 독립적이므로, 위치별 최소 조작 수를 더하면 됨
- 문자 `c`를 만들 때 필요한 조작 수는 다음 중 더 작은 값
    - 위로 이동: `c - 'A'`
    - 아래로 이동: `'Z' - c + 1`

### 2. 가로 이동(커서 이동) 기본값

- 커서를 오른쪽으로만 이동하면 필요한 최소 횟수는 `n - 1`
- 하지만 문자열 중간에 연속된 `A` 구간이 있으면 그 구간은 굳이 방문할 필요가 없으므로, 중간에 방향을 꺾는 것이 이득일 수 있음

### 3. 연속된 `A` 구간을 스킵하기 위한 방향 전환

- `l`에서 방향을 꺾는다고 가정하고, `l+1`부터 연속된 `A`가 끝나는 지점 `r`을 찾음
    - `r`은 `l+1`에서 시작해 `name[r] != 'A'`가 되는 첫 위치(또는 끝)까지 전진
- 이때 커서 이동 후보는 두 가지를 비교
    - 오른쪽으로 `l`까지 갔다가 되돌아온 뒤(왼쪽), 남은 뒷부분으로 이동: `2*l + (n - r)`
    - 뒷부분을 먼저 처리하려고 더 크게 되돌아가는 경우(대칭 케이스): `l + 2*(n - r)`
- 모든 `l`에 대해 위 값을 계산해 최소값으로 갱신

### 4. 왜 `for`문을 돌면서 매번 연속 `A`를 체크해야 하나?

- 최적 경로는 "어디서 방향을 꺾는지"에 의해 결정되고, 그 판단은 `l` 바로 다음에 나오는 연속 `A`의 길이에 크게 좌우됨
- 연속 `A` 구간은 여러 곳에 있을 수 있고(길이도 다름), 어떤 지점에서는 스킵이 큰 이득이지만 다른 지점에서는 이득이 없을 수 있음
- 그래서 각 `l`을 방향 전환 후보로 두고, 매번 `l+1`부터 연속 `A`의 끝(`r`)을 찾아 `n - r`(뒤쪽에 실제로 방문해야 하는 구간 길이)을 정확히 계산해야 함

## 코드


```python
def solution(name):
    answer = 0
    move = len(name)-1
    for l in range(len(name)):
        answer += min(ord(name[l]) - ord('A'), ord('Z') - ord(name[l]) + 1)
        r = l + 1
        while(r < len(name) and name[r] == 'A'):
            r += 1
        move = min(move, l*2+len(name)-r, l+2*(len(name)-r))
    answer += move
    return answer
```
