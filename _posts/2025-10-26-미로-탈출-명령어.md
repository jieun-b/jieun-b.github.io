---
title: "[2023 KAKAO BLIND RECRUITMENT] 미로 탈출 명령어"
date: 2025-10-26 00:00:00 +0900
layout: post
categories: [공부, Algorithm]
tags: [구현, 시뮬레이션]
---
## 문제

[**Level 3: 미로 탈출 명령어**](https://school.programmers.co.kr/learn/courses/30/lessons/150365)

### 문제 요약

- 크기 `n × m` 격자에서 시작점 `(x, y)`에서 목표점 `(r, c)`까지 정확히 `k`번 이동해 도달해야 함
- `(x, y)`와 `(r, c)`를 포함해 같은 격자 두 번 이상 방문 가능
- 한 번 이동 시 상하좌우(d, l, r, u) 중 한 방향으로 한 칸 이동 가능
- 가능한 경로 중 사전 순으로 가장 빠른 이동 문자열을 구하는 문제
- 도달이 불가능한 경우 `"impossible"` 출력

## 풀이 아이디어

- 현재 위치에서 목표까지의 **최소 거리**(`|x-r| + |y-c|`)가 `k`보다 크면 절대 도달 불가
- `(k - 최소거리)`가 **홀수**이면 이동을 반복해도 목표에 도달할 수 없음
- 사전 순으로 가장 작은 경로여야 하기 때문에 모든 이동은 **맨 아래(`d`) → 왼쪽(`l`) → 오른쪽(`r`) → 위(`u`)** 순으로 탐색해 가능한 빠르게 이동해야 함

### 이동 시뮬레이션

- `k`번 이동해야 하므로 매번 한 칸씩 이동
- 매 단계에서 4방향(`d, l, r, u`)을 순서대로 확인하며 남은 횟수 내에 목표까지 도달 가능한지 확인

## 코드

```python
def solution(n, m, x, y, r, c, k):
    answer = ''
    
    direction = [(1,0), (0,-1), (0,1), (-1,0)]
    alphabet = ['d', 'l', 'r', 'u']
    
    distance = abs(x-r)+abs(y-c)
    if distance > k or (k-distance)%2==1:
        return "impossible"
    
    n_k = k        
    for _ in range(k):
        n_k -= 1
        for i in range(4):
            nx, ny = x+direction[i][0], y+direction[i][1]
            if 0<nx<=n and 0<ny<=m:
                distance = abs(nx-r)+abs(ny-c)
                if distance <= n_k and (n_k-distance)%2==0:
                    print(alphabet[i])
                    answer = answer+alphabet[i]
                    x, y = nx, ny
                    break

    return answer
```